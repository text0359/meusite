<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enchanted Pink Cinema Room</title>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" onerror="handleScriptError('PeerJS')"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js" onerror="handleScriptError('Particles.js')"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Estilos Gerais para o Corpo */
    body {
      background: linear-gradient(135deg, #f9a8d4, #f472b6, #ec4899);
      font-family: 'Arial', sans-serif;
      overflow-x: hidden; /* CRÍTICO: Evita rolagem horizontal em qualquer cenário */
      animation: gradientShift 15s ease infinite;
      padding: 0; /* REMOVIDO padding padrão do body */
    }
    /* Animação de Fundo Gradiente */
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* Contêiner Principal da Sala de Cinema */
    .cinema-container {
      background-color: rgba(255, 182, 193, 0.95);
      border-radius: 20px;
      padding: 20px; /* Padding padrão */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transform: translateY(20px);
      animation: floatIn 1s ease-out forwards;
      /* Ajustes de responsividade aprimorados */
      width: 100%; /* Agora ocupa 100% da largura do body */
      max-width: 900px; /* Limite em telas maiores para não esticar demais */
      margin: 0 auto; /* Centraliza o container horizontalmente, sem margem vertical padrão */
      box-sizing: border-box; /* Garante que padding não cause overflow */
    }
    /* Animação de Entrada do Contêiner */
    @keyframes floatIn {
      to { transform: translateY(0); opacity: 1; }
    }
    /* Estilo do Player de Vídeo */
    video {
      border: 4px solid #ec4899;
      border-radius: 15px;
      transition: opacity 0.5s ease;
      width: 100%; /* Essencial: O vídeo sempre ocupa a largura total do seu contêiner */
      height: auto; /* Mantém a proporção do vídeo */
      display: block; /* Remove espaço extra abaixo do vídeo */
    }
    /* Estilo dos Botões */
    button {
      background: linear-gradient(45deg, #f472b6, #ec4899);
      color: white;
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      transition: transform 0.2s, box-shadow 0.2s;
      position: relative;
      overflow: hidden;
      width: 100%; /* Botões sempre ocupam 100% da largura em pequenos dispositivos */
      font-size: 1rem; /* Garante tamanho legível */
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(236, 72, 153, 0.7);
    }
    button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.4s, height 0.4s;
    }
    button:active::after {
      width: 200px;
      height: 200px;
    }
    /* Estilo da Área de Upload de Arquivos */
    .file-upload {
      background-color: #fef2f2;
      border: 3px dashed #f472b6;
      padding: 15px;
      border-radius: 15px;
      transition: transform 0.3s ease;
      box-sizing: border-box; /* Garante que padding não cause overflow */
    }
    .file-upload:hover {
      transform: scale(1.02);
    }
    /* Estilo do Menu Lateral */
    .menu {
      background: rgba(244, 114, 182, 0.9);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease; /* Adicionada transição para opacidade */
      z-index: 100; /* Garante que o menu fique sobre outros elementos */
      width: 80%; /* Ocupa mais largura em celulares para melhor usabilidade */
      max-width: 280px; /* Limita a largura máxima em telas maiores */
      box-sizing: border-box; /* Garante que padding não cause overflow */
      padding: 1rem; /* Espaçamento interno */
      pointer-events: auto; /* Permite interações quando visível */
    }
    .menu-hidden {
      transform: translateX(-150%); /* Aumentada a translação para garantir que suma completamente */
      opacity: 0; /* Torna o menu completamente invisível */
      pointer-events: none; /* Impede cliques em elementos invisíveis */
    }
    /* Estilo dos Itens da Lista de Cenas */
    .scene-item {
      cursor: pointer;
      transition: background-color 0.3s;
      padding: 0.75rem; /* Ajuste para melhor toque */
      border-radius: 8px; /* Cantos arredondados */
    }
    .scene-item:hover {
      background-color: #f9a8d4;
    }
    /* Partículas de Fundo */
    #particles-js {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    /* Estilos de Status de Conexão */
    .status-connected { color: #10b981; }
    .status-error { color: #ef4444; }

    /* NOVO: Estilos para Overlay de Reações */
    #reactionOverlay {
      position: absolute; /* **AGORA ABSOLUTO para ficar dentro do video-player-wrapper** */
      inset: 0; /* Cobre todo o wrapper do vídeo */
      z-index: 90; /* Abaixo do menu, mas acima do conteúdo */
      pointer-events: none; /* Não bloqueia interação com a tela */
      overflow: hidden; /* Garante que emojis não saiam da tela se a animação os levar longe */
    }

    .reaction-emoji {
      position: absolute;
      font-size: 3rem; /* Tamanho inicial do emoji */
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.5); /* Centraliza e diminui */
      animation: fade-slide-up 2.5s ease-out forwards; /* Animação */
      text-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* Sombra para destaque */
    }

    /* Animação do Emoji */
    @keyframes fade-slide-up {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5) translateY(50px);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1) translateY(0);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.9) translateY(-50px);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.7) translateY(-100px);
      }
    }

    /* NOVO: Estilos para o Wrapper do Player de Vídeo e Overlays Internos */
    .video-player-wrapper {
      position: relative;
      width: 100%;
      height: auto;
      max-width: 100%;
      overflow: hidden;
      border-radius: 15px; /* Arredondamento igual ao vídeo */
      box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Sombra suave */
      /* Garante que o wrapper tenha altura para o overlay */
      padding-top: 56.25%; /* 16:9 Aspect Ratio (9 / 16 * 100%) */
      background-color: black; /* Fundo para quando não há vídeo */
    }

    .video-player-wrapper video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain; /* Garante que o vídeo se ajuste sem cortar */
    }

    .video-player-overlay {
      position: absolute;
      inset: 0; /* Cobre todo o wrapper do vídeo */
      z-index: 10; /* Acima do vídeo, abaixo dos controles nativos do navegador */
      pointer-events: none; /* Permite que cliques passem para o vídeo por padrão, exceto em botões */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 1rem; /* Padding interno para os botões */
      background-color: rgba(0,0,0,0); /* **Inicia totalmente transparente** */
      opacity: 0; /* **Inicia oculto** */
      transition: background-color 0.3s ease, opacity 0.3s ease;
    }

    /* Efeito de hover no wrapper para escurecer o overlay e mostrar controles */
    .video-player-wrapper:hover .video-player-overlay,
    .video-player-overlay.show-overlay { /* Classe JS para mostrar no touch */
      opacity: 1; /* Totalmente visível no hover/touch */
      background-color: rgba(0,0,0,0.15); /* Fundo sutilmente translúcido */
    }

    /* Estilo do botão central de Play/Pause */
    #overlayPlayPauseButton {
      pointer-events: auto; /* Torna o botão clicável */
      background-color: rgba(236, 72, 153, 0.7); /* Rosa com transparência */
      color: white;
      border-radius: 9999px; /* Círculo completo */
      padding: 1rem;
      font-size: 3rem; /* Ícone grande */
      opacity: 0; /* **Inicia oculto** */
      transition: opacity 0.3s ease, background-color 0.2s ease;
      flex-shrink: 0; /* Evita encolhimento */
      display: flex;
      align-items: center;
      justify-content: center;
      width: 80px; /* Tamanho fixo */
      height: 80px; /* Tamanho fixo */
      margin: auto; /* Centraliza horizontal e verticalmente */
    }

    /* Mostrar o botão de play/pause no hover, ou se estiver pausado, ou se a classe 'show-button' estiver ativa */
    .video-player-wrapper:hover #overlayPlayPauseButton,
    #overlayPlayPauseButton.is-paused, /* **Sempre visível quando pausado** */
    #overlayPlayPauseButton.show-button { /* **Visível por um tempo no touch** */
      opacity: 0.9; /* Um pouco transparente */
    }

    #overlayPlayPauseButton:hover {
      opacity: 1; /* Totalmente opaco no hover direto no botão */
      background-color: rgba(236, 72, 153, 1);
    }

    /* Estilo dos botões de reação dentro do vídeo */
    .reaction-buttons-in-video {
        display: flex;
        justify-content: flex-end; /* Alinha à direita */
        align-items: flex-end; /* Alinha à parte inferior */
        gap: 0.5rem; /* Espaçamento entre botões */
        pointer-events: auto; /* Permite clicar nos botões */
        opacity: 0; /* **Inicia oculto** */
        transition: opacity 0.3s ease;
        padding-bottom: 0.5rem; /* Espaço na parte inferior para não colar na borda */
    }

    .video-player-wrapper:hover .reaction-buttons-in-video,
    .reaction-buttons-in-video.show-buttons { /* Classe JS para mostrar no touch */
        opacity: 0.8; /* **Visível com transparência no hover/touch** */
    }

    .reaction-buttons-in-video button {
      background: linear-gradient(45deg, #f472b6, #ec4899); /* **Botões de reação usam o mesmo gradiente dos outros** */
      color: white;
      border-radius: 9999px; /* Círculo completo */
      padding: 0.5rem;
      font-size: 1.5rem; /* Tamanho do emoji */
      transition: opacity 0.2s ease, background-color 0.2s ease;
      width: 50px; /* Tamanho fixo para facilitar o toque */
      height: 50px; /* Tamanho fixo */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reaction-buttons-in-video button:hover {
      opacity: 1; /* Totalmente opaco no hover direto no botão */
      background-color: rgba(236, 72, 153, 1);
    }

    /* NOVO: Estilos da Tela de Introdução */
    #introScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(45deg, #a020f0, #d8bfd8, #ff69b4); /* Gradiente roxo-rosa */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200; /* Acima de tudo */
        color: white;
        text-shadow: 0 0 10px rgba(0,0,0,0.5);
        transition: opacity 1s ease-out; /* Transição de fade-out */
        opacity: 1;
    }

    #introScreen.fade-out {
        opacity: 0;
        pointer-events: none; /* Impede cliques após fade-out */
    }

    #introTitle {
        font-family: 'Times New Roman', serif; /* Fonte clássica de cinema */
        font-size: 3rem; /* Tamanho grande */
        font-weight: bold;
        margin-bottom: 2rem;
        text-align: center;
        padding: 0 1rem;
        /* NOVO: Animação de entrada e depois o brilho */
        animation: fadeInScale 1s ease-out forwards, neonGlow 1.5s ease-in-out infinite alternate 1s;
    }

    /* NOVO: Animação de Fade-in e Escala para elementos da introdução */
    @keyframes fadeInScale {
        0% { opacity: 0; transform: scale(0.8); }
        100% { opacity: 1; transform: scale(1); }
    }

    @keyframes neonGlow {
        from { text-shadow: 0 0 5px #fff, 0 0 10px #ff69b4, 0 0 20px #ff69b4, 0 0 30px #ff69b4; }
        to { text-shadow: 0 0 10px #fff, 0 0 20px #ff69b4, 0 0 30px #ff69b4, 0 0 40px #ff69b4; }
    }

    #introVideoContainer {
        width: 80%; /* Tamanho do mini-filme */
        max-width: 600px;
        border: 5px solid #ff69b4;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 2rem;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        /* NOVO: Animação de entrada e brilho na borda */
        animation: fadeInScale 1.5s ease-out forwards, borderGlow 2s ease-in-out infinite alternate;
    }

    /* NOVO: Animação para o brilho da borda do vídeo */
    @keyframes borderGlow {
        from { border-color: #ff69b4; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        to { border-color: #f9a8d4; box-shadow: 0 0 30px #f9a8d4, 0 0 40px #ff69b4; }
    }


    #introVideo {
        width: 100%;
        height: auto;
        display: block;
    }

    #loadingBarContainer {
        width: 70%;
        max-width: 400px;
        background-color: rgba(255,255,255,0.3);
        border-radius: 5px;
        height: 10px;
        overflow: hidden;
        margin-top: 1rem;
    }

    #loadingBar {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #f472b6, #ec4899); /* Barra rosa/dourada */
        animation: loadingFill 12s linear forwards; /* Animação de preenchimento */
    }

    @keyframes loadingFill {
        from { width: 0%; }
        to { width: 100%; }
    }

    #loadingText {
        margin-top: 0.5rem;
        font-size: 1.2rem;
        color: #f9a8d4;
    }
    
    /* NOVO: Estilo para o botão de início na intro screen */
    #startButton {
        background: linear-gradient(45deg, #a020f0, #ff69b4);
        color: white;
        padding: 15px 30px;
        border-radius: 15px;
        border: none;
        font-size: 1.5rem;
        font-weight: bold;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        margin-top: 2rem; /* Espaçamento do loading bar */
    }
    #startButton:hover {
        transform: scale(1.05);
        box-shadow: 0 0 20px rgba(255,105,180,0.7);
    }

    /* Custom Fullscreen Mode */
    .video-player-wrapper.custom-fullscreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1000; /* Above all other content */
        border-radius: 0; /* No rounded corners in fullscreen */
        padding-top: 0; /* No aspect ratio padding in fullscreen */
        box-shadow: none;
    }

    .video-player-wrapper.custom-fullscreen video {
        object-fit: contain; /* Ensure video fits within screen */
    }
    /* Ensure the controls are always visible in custom fullscreen */
    .video-player-wrapper.custom-fullscreen .video-player-overlay {
        opacity: 1;
        background-color: rgba(0,0,0,0.15); /* Slightly visible overlay */
    }
    .video-player-wrapper.custom-fullscreen #overlayPlayPauseButton,
    .video-player-wrapper.custom-fullscreen .reaction-buttons-in-video {
        opacity: 0.9; /* Slightly visible controls */
    }

    /* Hide native controls when in custom fullscreen */
    .video-player-wrapper.custom-fullscreen video::-webkit-media-controls-enclosure {
        display: none !important;
    }
    /* Para Firefox */
    .video-player-wrapper.custom-fullscreen video::-moz-media-controls {
        display: none !important;
    }
    /* Para Edge/IE */
    .video-player-wrapper.custom-fullscreen video::-ms-media-controls {
        display: none !important;
    }
    /* Genérico - pode não funcionar em todos os browsers */
    .video-player-wrapper.custom-fullscreen video::media-controls-container {
        display: none !important;
    }


    /* Media Queries para Ajustes Mais Finos em Telas de Celular */
    @media (max-width: 768px) { /* Para tablets e celulares */
      .cinema-container {
        padding: 15px; /* Reduz o padding geral para economizar espaço */
        border-radius: 15px; /* Ajusta o raio da borda */
      }
      h1 {
        font-size: 2rem; /* Títulos menores para caber melhor */
        margin-bottom: 1rem;
      }
      button {
        padding: 10px 15px; /* Botões um pouco menores */
        margin-bottom: 0.75rem; /* Espaçamento entre botões */
      }
      .flex-col-mobile { /* Usado para forçar empilhamento de botões, se necessário */
        flex-direction: column;
      }
      .input-full-width { /* Garante inputs que ocupam toda a largura */
        width: 100%;
        box-sizing: border-box;
      }
      .space-y-2 > *:not([hidden]) ~ *:not([hidden]) {
        margin-top: 0.5rem; /* Ajusta espaçamento vertical para elementos empilhados */
      }
      .reaction-emoji {
        font-size: 2.5rem; /* Menor em telas menores */
      }
      /* Ajustes para botões no vídeo em telas menores */
      #overlayPlayPauseButton {
        font-size: 2.5rem;
        width: 60px;
        height: 60px;
      }
      .reaction-buttons-in-video button {
        font-size: 1.25rem;
        width: 40px;
        height: 40px;
      }
      .reaction-buttons-in-video {
        gap: 0.3rem; /* Menor espaçamento entre botões em telas pequenas */
      }

      #introTitle {
          font-size: 2.5rem;
      }
      #introVideoContainer {
          width: 90%;
      }
      #loadingBarContainer {
          width: 80%;
      }
      #loadingText {
          font-size: 1rem;
      }
      #startButton {
          font-size: 1.2rem;
          padding: 12px 25px;
      }
    }

    @media (max-width: 480px) { /* Para celulares muito pequenos */
      .cinema-container {
        padding: 10px;
        border-radius: 10px; /* Cantos um pouco menos arredondados para economizar espaço */
      }
      h1 {
        font-size: 1.75rem; /* Títulos ainda menores */
      }
      button {
        font-size: 0.9rem;
        padding: 8px 12px;
        border-radius: 10px;
      }
      .menu {
        width: 90%; /* Menu ainda maior em telas muito pequenas */
      }
      .file-upload {
        padding: 10px;
      }
      .reaction-emoji {
        font-size: 2rem; /* Ainda menor em telas muito pequenas */
      }
      /* Ajustes para botões no vídeo em telas muito pequenas */
      #overlayPlayPauseButton {
        font-size: 2rem;
        width: 50px;
        height: 50px;
      }
      .reaction-buttons-in-video button {
        font-size: 1rem;
        width: 35px;
        height: 35px;
      }

      #introTitle {
          font-size: 1.8rem;
      }
      #introVideoContainer {
          width: 95%;
      }
      #loadingBarContainer {
          width: 90%;
      }
      #loadingText {
          font-size: 0.9rem;
      }
      #startButton {
          font-size: 1rem;
          padding: 10px 20px;
      }
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
  <div id="particles-js"></div>
  
  <div id="introScreen">
    <h1 id="introTitle">Werveson & Leticia's Home Cinema</h1>
    <div id="introVideoContainer">
        <video id="introVideo" loop muted playsinline>
            <source src="https://www.learningcontainer.com/wp-content/uploads/2020/05/sample-mp4-file.mp4" type="video/mp4">
            Seu navegador não suporta a tag de vídeo.
        </video>
    </div>
    <p id="loadingText">Carregando a experiência...</p>
    <div id="loadingBarContainer">
        <div id="loadingBar"></div>
    </div>
    <button id="startButton" onclick="startCinemaExperience(true)">Iniciar Cinema</button>
  </div>

  <audio id="clickSound1" src="https://freesound.org/data/previews/171/171671_2437358-lq.mp3" onerror="handleAudioError('Click Sound 1')"></audio>
  <audio id="clickSound2" src="https://freesound.org/data/previews/171/171668_2437358-lq.mp3" onerror="handleAudioError('Click Sound 2')"></audio>
  <audio id="clickSound3" src="https://freesound.org/data/previews/171/171670_2437358-lq.mp3" onerror="handleAudioError('Click Sound 3')"></audio>

  <audio id="bgMusic" src="https://freesound.org/data/previews/235/235655_4229646-lq.mp3" loop muted onerror="handleAudioError('Background Music')"></audio>

  <div class="cinema-container w-full sm:max-w-xl md:max-w-3xl lg:max-w-5xl xl:max-w-6xl mx-auto relative flex flex-col items-center p-4 hidden">
    <h1 class="text-3xl sm:text-4xl font-bold text-pink-800 text-center mb-6 sm:mb-8 animate-pulse mt-4">
      Enchanted Pink Cinema Room
    </h1>
    
    <button onclick="toggleMenu()" class="absolute top-4 left-4 z-50 px-4 py-2 text-white rounded-lg text-sm sm:text-base">
      Menu
    </button>

    <div id="menu" class="menu fixed top-0 left-0 h-full w-3/4 sm:w-64 p-4 menu-hidden shadow-lg">
      <h2 class="text-2xl text-pink-800 mb-4">Menu</h2>
      <button onclick="toggleMenu()" class="mb-4">Fechar Menu</button>
      <div class="space-y-3 mt-4">
        <button onclick="uploadAndShareFile()">Carregar & Transmitir Vídeo</button>
        <button onclick="syncPlay()">Sincronizar Play</button>
        <button onclick="syncPause()">Sincronizar Pausar</button>
        <button onclick="addScene()">Adicionar Cena</button>
      </div>
      <h3 class="text-xl text-pink-700 mt-6 mb-2">Cenas</h3>
      <ul id="sceneList" class="text-pink-800 space-y-2 max-h-48 overflow-y-auto"></ul>
    </div>
    
    <div class="w-full mb-6 text-center fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Conectar com Amigo</h2>
      <p class="text-pink-800 mb-2">Seu Peer ID: <span id="myPeerId" class="font-bold"></span></p>
      <p id="connectionStatus" class="text-pink-800 mb-2">Status: Desconectado</p>
      <input id="remotePeerId" type="text" placeholder="Insira o Peer ID do amigo" 
             class="w-full p-2 mb-4 text-pink-800 border border-pink-700 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-transparent text-base">
      <div class="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-2">
        <button onclick="connectToPeer()" class="text-base">Conectar</button>
        <button onclick="retryConnection()" class="text-base">Tentar Novamente</button>
      </div>
    </div>
    
    <div class="w-full mb-6 fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Player de Filme</h2>
      <div class="video-player-wrapper">
        <video id="moviePlayer" controls class="w-full h-auto block bg-black">
          <source id="movieSource" src="" type="video/mp4">
          Seu navegador não suporta a tag de vídeo.
        </video>

        <div id="reactionOverlay" class="absolute inset-0 pointer-events-none overflow-hidden"></div>

        <div id="videoOverlayControls" class="video-player-overlay">
          <div class="flex flex-grow items-center justify-center">
              <button id="overlayPlayPauseButton" onclick="toggleOverlayPlayPause()">
                  <span id="overlayPlayIcon">▶️</span>
                  <span id="overlayPauseIcon" class="hidden">⏸️</span>
              </button>
          </div>

          <div class="flex justify-end items-end gap-2 p-2 w-full"> 
              <div id="reactionButtonsInVideo" class="flex justify-end gap-2 reaction-buttons-in-video">
                  <button onclick="sendReaction('❤️')">❤️</button>
                  <button onclick="sendReaction('😂')">😂</button>
                  <button onclick="sendReaction('✋')">✋</button>
                  <button onclick="sendReaction('😮')">😮</button>
                  <button onclick="sendReaction('😢')">😢</button>
                  <button onclick="sendReaction('✨')">✨</button>
              </div>
              <button id="customFullscreenButton" onclick="toggleCustomFullscreen()" class="ml-2 bg-pink-600 hover:bg-pink-700 p-2 rounded-lg text-lg">
                  ↔️
              </button>
          </div>
        </div>
      </div>
    </div>
    
    <div class="file-upload w-full mb-6 fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Carregar um Filme/Vídeo</h2>
      <input type="file" id="fileInput" accept="video/*" class="mb-4 text-pink-800 w-full text-base">
      <button onclick="uploadAndShareFile()" class="text-base">Carregar & Transmitir Vídeo</button>
      
      <div class="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-2 mt-2">
        <button onclick="shareFileForDownload()" class="text-base">Enviar Arquivo para Download</button>
        <button id="cancelDownloadButton" onclick="cancelFileDownload()" class="text-base bg-red-500 hover:bg-red-600 hidden">Cancelar Download</button>
      </div>

      <div id="downloadSection" class="mt-4 text-center"></div>
      <p id="streamingStatus" class="w-full mt-4 text-center text-pink-800 font-semibold text-sm sm:text-base hidden"></p>
      <p id="downloadProgressStatus" class="w-full mt-4 text-center text-pink-800 font-semibold text-sm sm:text-base hidden"></p>
      
      <p class="text-xs text-pink-700 mt-2">
        A velocidade do download Peer-to-Peer depende da sua conexão e da do seu amigo. <br>
        Para compartilhar links públicos ou downloads mais rápidos de arquivos grandes, um servidor externo seria necessário.
      </p>
    </div>

  </div>

  <script>
    // Variáveis globais para PeerJS e elementos do DOM
    let peer;
    let conn;
    let currentFileUrl = null;
    let scenes = [];
    const moviePlayer = document.getElementById('moviePlayer');
    const movieSource = document.getElementById('movieSource');
    const fileInput = document.getElementById('fileInput');
    const downloadSection = document.getElementById('downloadSection');
    const myPeerIdDisplay = document.getElementById('myPeerId');
    const remotePeerIdInput = document.getElementById('remotePeerId');
    const connectionStatus = document.getElementById('connectionStatus');
    const sceneList = document.getElementById('sceneList');
    
    // Array de URLs de sons de clique para variedade
    const clickSounds = [
      new Audio("https://freesound.org/data/previews/171/171671_2437358-lq.mp3"), // Click original
      new Audio("https://freesound.org/data/previews/171/171668_2437358-lq.mp3"), // Click 2
      new Audio("https://freesound.org/data/previews/171/171670_2437358-lq.mp3")  // Click 3
    ];
    clickSounds.forEach(s => s.volume = 0.1); // Reduz o volume dos sons de clique
    
    const bgMusic = document.getElementById('bgMusic');
    const reactionOverlay = document.getElementById('reactionOverlay'); 
    // Variáveis para controle de download
    let receivedFiles = new Map(); 
    let currentFileReader = null; 
    let currentFileTransferId = null; 

    let isSyncing = false;

    // Elementos do overlay de play/pause
    const overlayPlayPauseButton = document.getElementById('overlayPlayPauseButton');
    const overlayPlayIcon = document.getElementById('overlayPlayIcon');
    const overlayPauseIcon = document.getElementById('overlayPauseIcon');
    const videoPlayerWrapper = document.querySelector('.video-player-wrapper'); 
    const videoOverlayControls = document.getElementById('videoOverlayControls'); 
    const reactionButtonsInVideo = document.getElementById('reactionButtonsInVideo'); 

    // Elementos da Tela de Introdução
    const introScreen = document.getElementById('introScreen');
    const introVideo = document.getElementById('introVideo');
    const cinemaContainer = document.querySelector('.cinema-container');
    const loadingBar = document.getElementById('loadingBar'); // Referência à barra de carregamento
    const loadingText = document.getElementById('loadingText'); // Referência ao texto de carregamento
    const customFullscreenButton = document.getElementById('customFullscreenButton'); // Botão de tela cheia customizada
    let isCustomFullscreen = false; // Estado da tela cheia customizada

    // Variável para o ID do setTimeout da transição da intro
    let introScreenTimeoutId;

    // Funções de tratamento de erro para scripts e áudios
    function handleScriptError(scriptName) {
      connectionStatus.textContent = `Status: Erro ao carregar ${scriptName}. Por favor, atualize a página.`;
      connectionStatus.classList.add('status-error');
      console.error(`${scriptName} falhou ao carregar`);
    }

    function handleAudioError(audioName) {
      console.warn(`${audioName} falhou ao carregar. Considere hospedar arquivos de áudio localmente.`);
    }

    // Inicialização do Particle.js para efeitos visuais
    if (typeof particlesJS !== 'undefined') {
      particlesJS('particles-js', {
        particles: {
          number: { value: 80, density: { enable: true, value_area: 800 } },
          color: { value: '#f9a8d4' },
          shape: { type: 'circle' },
          opacity: { value: 0.5, random: true },
          size: { value: 3, random: true },
          line_linked: { enable: false },
          move: { enable: true, speed: 2, direction: 'none', random: true }
        },
        interactivity: { detect_on: 'canvas', events: { onhover: { enable: true, mode: 'repulse' } } }
      });
    } else {
      console.warn('Particle.js não carregado');
    }

    // Função para iniciar a experiência do cinema após o clique do usuário ou timeout
    function startCinemaExperience(fromButtonClick = false) {
        // Limpa o setTimeout que faria a transição automática após 12 segundos
        clearTimeout(introScreenTimeoutId);

        // Desmuta e tenta tocar a música de fundo (se ainda não estiver tocando)
        bgMusic.muted = false; // Desmuta a música
        bgMusic.play().catch(e => {
            console.log("Música de fundo bloqueada ou falhou ao tocar:", e);
        });

        // Desmuta e tenta tocar o vídeo da introdução (se ainda não estiver tocando)
        introVideo.muted = false; // Desmuta o vídeo
        introVideo.play().catch(e => console.log("Vídeo da introdução bloqueado ou falhou ao tocar:", e));

        // Transição da tela de introdução para a sala de cinema principal
        introScreen.classList.add('fade-out');
        
        // Pausar e resetar áudio/vídeo da introdução APÓS o fade-out
        setTimeout(() => {
            introScreen.style.display = 'none';
            cinemaContainer.classList.remove('hidden'); // Mostra o cinema container
            cinemaContainer.classList.add('float-in'); // Garante a animação de entrada
            
            // Pausar e resetar o vídeo da introdução
            introVideo.pause();
            introVideo.currentTime = 0;
            introVideo.muted = true; // Garante que permaneça mutado se iniciado de novo

            // Pausar e resetar a música de fundo (RPG)
            bgMusic.pause();
            bgMusic.currentTime = 0;
            bgMusic.muted = true; // Garante que permaneça mutada
        }, 1000); // Tempo da transição de fade-out

        // Se a chamada veio do botão, reinicia a animação da barra para 'completar' imediatamente
        if (fromButtonClick) {
            loadingBar.style.animation = 'none'; // Reseta a animação
            void loadingBar.offsetWidth; // Trigger reflow
            loadingBar.style.animation = 'loadingFill 0.5s ease-out forwards'; // Completa rapidamente
            loadingText.textContent = "Iniciando cinema...";
        }
    }

    // Executa a configuração inicial da tela de introdução ao carregar a página
    window.addEventListener('load', () => {
        // Tenta tocar a música de fundo (mutada) e o vídeo da introdução (mutado)
        // Eles estarão mutados para tentar contornar a política de autoplay
        bgMusic.volume = 0.3;
        bgMusic.muted = true; // Garante que comece mutado
        // Tenta tocar, mas pode ser bloqueado pelo navegador até a primeira interação
        bgMusic.play().catch(e => console.log("Música de fundo bloqueada em load (mutada):", e));

        introVideo.muted = true; // Garante que o vídeo de introdução comece mutado
        // Tenta tocar, mas pode ser bloqueado pelo navegador até a primeira interação
        introVideo.play().catch(e => console.log("Vídeo da introdução bloqueado em load (mutado):", e));

        // Inicia a animação da barra de carregamento e define o timeout para a transição automática
        loadingBar.style.animation = 'loadingFill 12s linear forwards';
        loadingText.textContent = "Carregando a experiência...";

        // Define o timeout para a transição automática após 12 segundos
        introScreenTimeoutId = setTimeout(() => {
            startCinemaExperience(false); // Chama a função de início (não veio de um clique no botão)
        }, 12000); // 12 segundos para a introdução
    });


    // Adiciona som de clique a todos os botões
    document.querySelectorAll('button').forEach(button => {
      button.addEventListener('click', () => {
        // Toca um som de clique aleatório
        const randomClickSound = clickSounds[Math.floor(Math.random() * clickSounds.length)];
        randomClickSound.currentTime = 0; // Reinicia o som
        randomClickSound.play().catch(() => console.log('Som de clique bloqueado'));
      });
    });

    // Função para alternar a visibilidade do menu lateral
    function toggleMenu() {
      const menu = document.getElementById('menu');
      menu.classList.toggle('menu-hidden');
    }

    // Inicialização do PeerJS com servidores STUN/TURN para melhor conectividade
    peer = new Peer({
      host: '0.peerjs.com',
      secure: true,
      port: 443,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay.project', credential: 'openrelayproject' }
        ]
      }
    });

    // Evento quando o PeerJS é aberto e recebe um ID
    peer.on('open', (id) => {
      myPeerIdDisplay.textContent = id;
      connectionStatus.textContent = 'Status: Aguardando conexão...';
      connectionStatus.classList.remove('status-error', 'status-connected');
      console.log('PeerJS inicializado com ID:', id);
    });

    // Evento para lidar com novas conexões recebidas
    peer.on('connection', (connection) => {
      conn = connection;
      setupConnection();
    });

    // Evento para lidar com erros do PeerJS
    peer.on('error', (err) => {
      connectionStatus.textContent = `Status: Erro - ${err.type}. ${err.type === 'peer-unavailable' ? 'Verifique o Peer ID ou garanta que o amigo esteja online.' : 'Erro de rede/servidor. Tentando reconectar...'}`;
      connectionStatus.classList.add('status-error');
      console.error('PeerJS error:', err);

      // Tenta reconectar se a conexão com o servidor for perdida
      if (err.type === 'peer-disconnected' || err.type === 'network' || err.type === 'server-disconnected') {
        if (reconnectPeerTimeout) clearTimeout(reconnectPeerTimeout);
        reconnectPeerTimeout = setTimeout(() => {
          console.log('Tentando reconectar ao servidor PeerJS...');
          peer.reconnect(); // O PeerJS tem um método embutido para reconectar
        }, 5000); // Tenta reconectar após 5 segundos
      }
    });

    peer.on('close', () => {
      connectionStatus.textContent = 'Status: Desconectado do servidor. Tentando reconectar...';
      connectionStatus.classList.add('status-error');
      console.log('Conexão PeerJS com o servidor fechada.');

      // Agenda a reconexão automática
      if (reconnectPeerTimeout) clearTimeout(reconnectPeerTimeout);
      reconnectPeerTimeout = setTimeout(() => {
        console.log('Tentando reconectar ao servidor PeerJS após evento de fechamento...');
        peer.reconnect();
      }, 5000); // Tenta reconectar após 5 segundos
    });

    // Função para iniciar a conexão com outro Peer
    function connectToPeer() {
      const remoteId = remotePeerIdInput.value.trim();
      if (remoteId) {
        connectionStatus.textContent = 'Status: Conectando...';
        connectionStatus.classList.remove('status-error', 'status-connected');
        conn = peer.connect(remoteId);
        setupConnection();
      } else {
        connectionStatus.textContent = 'Status: Insira um Peer ID válido';
        connectionStatus.classList.add('status-error');
        console.warn('Nenhum Peer ID inserido');
      }
    }

    // Função para tentar novamente a conexão PeerJS
    function retryConnection() {
      if (remotePeerIdInput.value.trim()) {
        connectionStatus.textContent = 'Status: Tentando novamente a conexão...';
        connectionStatus.classList.remove('status-error', 'status-connected');
        peer.destroy(); // Destrói a instância PeerJS atual
        // Cria uma nova instância PeerJS
        peer = new Peer({
          host: '0.peerjs.com',
          secure: true,
          port: 443,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay.project', credential: 'openrelayproject' }
            ]
          }
        });
        peer.on('open', (id) => {
          myPeerIdDisplay.textContent = id;
          connectionStatus.textContent = 'Status: Aguardando conexão...';
          connectToPeer(); // Tenta conectar automaticamente após reabrir
        });
        peer.on('error', (err) => {
          connectionStatus.textContent = `Status: Erro - ${err.type}. ${err.type === 'peer-unavailable' ? 'Verifique o Peer ID ou garanta que o amigo esteja online.' : 'Verifique a rede ou tente novamente.'}`;
          connectionStatus.classList.add('status-error');
          console.error('Erro PeerJS:', err);
        });
        peer.on('connection', (connection) => {
          conn = connection;
          setupConnection();
        });
      } else {
        connectionStatus.textContent = 'Status: Insira um Peer ID válido para tentar novamente';
        connectionStatus.classList.add('status-error');
      }
    }

    // Função para atualizar o status do streaming (não é progresso de download de arquivo)
    function updateStreamingStatus(text, hideAfterDelay = true) {
      const statusDiv = document.getElementById('streamingStatus');
      statusDiv.textContent = text;
      statusDiv.classList.remove('hidden');
      if (hideAfterDelay) {
        setTimeout(() => { statusDiv.classList.add('hidden'); }, 5000);
      }
    }

    // Função para atualizar o progresso do download do arquivo
    function updateDownloadStatus(received, total, fileName = '') {
      const statusDiv = document.getElementById('downloadProgressStatus');
      statusDiv.classList.remove('hidden');
      if (total === 0) {
        statusDiv.textContent = '';
        statusDiv.classList.add('hidden');
        return;
      }
      const percentage = Math.min(100, Math.floor((received / total) * 100));
      let statusText = `Baixando '${fileName}': ${percentage}%`;

      if (percentage === 100) {
        statusDiv.textContent = `${statusText} - Completo!`;
        setTimeout(() => { statusDiv.classList.add('hidden'); }, 3000);
      } else {
        statusDiv.textContent = statusText;
      }
    }

    // Função para exibir uma reação animada (AGORA DENTRO DO VÍDEO)
    function displayReaction(emoji) {
        const reactionDiv = document.createElement('div');
        reactionDiv.className = 'reaction-emoji';
        reactionDiv.textContent = emoji;

        // Calcula a posição aleatória dentro das dimensões do player de vídeo
        const playerRect = moviePlayer.getBoundingClientRect(); // Dimensões e posição do player em relação à viewport
        // Garante que o emoji apareça um pouco afastado das bordas do vídeo
        // 60 é o tamanho aproximado do emoji + margem para não cortar
        const x = Math.random() * (playerRect.width - 60) + 30; 
        const y = Math.random() * (playerRect.height - 60) + 30; 
        
        // Posição do emoji dentro do overlay (que é absoluto em relação ao wrapper do vídeo)
        reactionDiv.style.left = `${x}px`;
        reactionDiv.style.top = `${y}px`;

        // Adiciona o emoji ao reactionOverlay que está dentro do video-player-wrapper
        reactionOverlay.appendChild(reactionDiv);

        // Remove o emoji após a animação (2.5 segundos)
        setTimeout(() => {
            reactionDiv.remove();
        }, 2500);
    }

    // Função para enviar a reação via PeerJS
    function sendReaction(emoji) {
        if (conn && conn.open) {
            conn.send({ type: 'reaction', emoji: emoji });
            console.log('Reação enviada:', emoji);
            displayReaction(emoji); // Exibe a reação localmente também
        } else {
            console.warn('Não conectado a um peer para enviar a reação.');
            displayReaction(emoji); // Apenas exibe localmente se não conectado
        }
    }

    // Função para atualizar o ícone do botão de play/pause no overlay
    function updateOverlayPlayPauseButtonIcon() {
        if (moviePlayer.paused) {
            overlayPlayIcon.classList.remove('hidden');
            overlayPauseIcon.classList.add('hidden');
            overlayPlayPauseButton.classList.remove('hidden'); // Mostra o botão quando pausado
            overlayPlayPauseButton.classList.add('is-paused'); // Adiciona classe para estilo de pausado
            // Se pausado, o overlay e botões de reação também devem ser visíveis
            videoOverlayControls.classList.add('show-overlay');
            reactionButtonsInVideo.classList.add('show-buttons');
        } else {
            overlayPlayIcon.classList.add('hidden');
            overlayPauseIcon.classList.remove('hidden');
            overlayPlayPauseButton.classList.add('hidden'); // Esconde o botão quando está tocando
            overlayPlayPauseButton.classList.remove('is-paused'); // Remove classe de pausado
            // Se tocando, esconde o overlay e botões de reação após um tempo
            videoOverlayControls.classList.remove('show-overlay');
            reactionButtonsInVideo.classList.remove('show-buttons');
        }
    }

    // Função para alternar play/pause no overlay
    function toggleOverlayPlayPause() {
        if (moviePlayer.paused) {
            moviePlayer.play();
        } else {
            moviePlayer.pause();
        }
    }

    // Funções para controlar a visibilidade do overlay (interação)
    let hideControlsTimeout;
    function showControlsTemporarily() {
        videoOverlayControls.classList.add('show-overlay');
        reactionButtonsInVideo.classList.add('show-buttons'); // Mostra botões de reação também
        overlayPlayPauseButton.classList.add('show-button'); // Mostra o botão central temporariamente

        clearTimeout(hideControlsTimeout);
        if (!moviePlayer.paused) { // Apenas esconde se o vídeo estiver tocando
            hideControlsTimeout = setTimeout(() => {
                videoOverlayControls.classList.remove('show-overlay');
                reactionButtonsInVideo.classList.remove('show-buttons');
                overlayPlayPauseButton.classList.remove('show-button');
            }, 3000); // Esconde após 3 segundos de inatividade
        }
    }

    // Função para alternar entre tela cheia customizada e modo normal
    function toggleCustomFullscreen() {
        if (!isCustomFullscreen) {
            // Entra em modo de tela cheia customizada (CSS)
            videoPlayerWrapper.classList.add('custom-fullscreen');
            // Esconde os controles nativos do HTML5 video (se eles não sumirem automaticamente)
            moviePlayer.removeAttribute('controls'); 
            isCustomFullscreen = true;
            customFullscreenButton.textContent = 'Shrink'; // Muda texto/ícone do botão
            // Força a exibição temporária dos controles customizados
            showControlsTemporarily(); 
        } else {
            // Sai do modo de tela cheia customizada
            videoPlayerWrapper.classList.remove('custom-fullscreen');
            // Mostra os controles nativos do HTML5 video novamente
            moviePlayer.setAttribute('controls', '');
            isCustomFullscreen = false;
            customFullscreenButton.textContent = '↔️'; // Muda texto/ícone do botão
        }
        // Re-chama a função para garantir que o estado dos ícones seja atualizado
        updateOverlayPlayPauseButtonIcon(); 
    }


    // Configura os ouvintes de evento para a conexão PeerJS
    function setupConnection() {
      conn.on('open', () => {
        connectionStatus.textContent = 'Status: Conectado!';
        connectionStatus.classList.add('status-connected');
        console.log('Conexão PeerJS estabelecida');

        // Adiciona ouvintes de evento ao player de vídeo após a conexão ser aberta
        moviePlayer.addEventListener('play', handlePlayerPlay);
        moviePlayer.addEventListener('pause', handlePlayerPause);
        moviePlayer.addEventListener('seeked', handlePlayerSeeked);
        
        // Adiciona ouvintes para o botão de overlay play/pause
        moviePlayer.addEventListener('play', updateOverlayPlayPauseButtonIcon);
        moviePlayer.addEventListener('pause', updateOverlayPlayPauseButtonIcon);
        moviePlayer.addEventListener('loadedmetadata', updateOverlayPlayPauseButtonIcon); // Para estado inicial
        
        // Ouvintes para mostrar/esconder o overlay de controles
        videoPlayerWrapper.addEventListener('mousemove', showControlsTemporarily); // Desktop
        videoPlayerWrapper.addEventListener('touchstart', showControlsTemporarily); // Mobile
        
        updateOverlayPlayPauseButtonIcon(); // Chama para definir o estado inicial
      });

      // Lida com o recebimento de stream de mídia (áudio/vídeo)
      peer.on('call', (call) => {
          console.log('Recebendo chamada de vídeo do peer...');
          updateStreamingStatus('Recebendo streaming...');
          
          call.answer(); // Responde à chamada de vídeo
          call.on('stream', (remoteStream) => {
              console.log('Stream de vídeo recebido do peer!');
              moviePlayer.srcObject = remoteStream; // Define o stream recebido como fonte do player
              moviePlayer.play().catch(e => console.error("Erro ao tentar tocar stream recebido:", e)); // Tenta dar play automaticamente
              updateStreamingStatus('Streaming recebido e reproduzindo!');
          });
          call.on('close', () => {
              console.log('Stream de vídeo encerrado.');
              updateStreamingStatus('Streaming encerrado.');
          });
      });

      conn.on('data', (data) => {
        // Lida com o início da transferência de arquivo para download
        if (data.type === 'file-download-start') {
          receivedFiles.set(data.fileTransferId, {
            fileName: data.fileName,
            fileType: data.fileType,
            totalChunks: data.totalChunks,
            receivedChunks: new Array(data.totalChunks), // Array para armazenar os chunks na ordem correta
            receivedSize: 0,
            fileSize: data.fileSize
          });
          console.log(`Recebendo arquivo para download: ${data.fileName} (${data.fileSize} bytes)`);
          updateDownloadStatus(0, data.fileSize, data.fileName);
        } 
        // Lida com os chunks de dados do arquivo para download
        else if (data.type === 'file-download-chunk') {
          const fileData = receivedFiles.get(data.fileTransferId);
          if (fileData) {
            fileData.receivedChunks[data.chunkIndex] = data.data; // Armazena o chunk na posição correta
            fileData.receivedSize += data.data.byteLength;
            updateDownloadStatus(fileData.receivedSize, fileData.fileSize, fileData.fileName);

            // Verifica se todos os chunks foram recebidos
            if (fileData.receivedSize === fileData.fileSize) {
                // Monta o arquivo completo a partir dos chunks
                const fullBlob = new Blob(fileData.receivedChunks, { type: fileData.fileType });
                const url = URL.createObjectURL(fullBlob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = fileData.fileName;
                downloadLink.textContent = `Baixar ${fileData.fileName}`;
                downloadLink.className = 'text-pink-700 underline mt-2 block';
                
                // Limpar links de download anteriores e adicionar o novo
                downloadSection.innerHTML = ''; 
                const downloadPrompt = document.createElement('p');
                downloadPrompt.className = 'text-pink-800 text-sm mt-2';
                downloadPrompt.textContent = 'Arquivo recebido para download:';
                downloadSection.appendChild(downloadPrompt);
                downloadSection.appendChild(downloadLink);

                console.log('Arquivo recebido e pronto para download:', fileData.fileName);

                receivedFiles.delete(data.fileTransferId); // Limpa o estado da transferência
                updateDownloadStatus(fileData.fileSize, fileData.fileSize, fileData.fileName); // Garante 100%
            }
          }
        }
        // Lida com a mensagem de cancelamento de download
        else if (data.type === 'cancel-download') {
            const fileData = receivedFiles.get(data.fileTransferId);
            if (fileData) {
                receivedFiles.delete(data.fileTransferId);
                updateDownloadStatus(0, 0, ''); // Limpa o status
                console.log(`Download de arquivo '${fileData.fileName}' cancelado pelo remetente.`);
                document.getElementById('downloadProgressStatus').textContent = `Download de '${fileData.fileName}' cancelado.`;
                setTimeout(() => { document.getElementById('downloadProgressStatus').classList.add('hidden'); }, 3000);
            }
        }
        // Lida com mensagens de sincronização (play, pause, seek)
        else if (data.type === 'play' || data.type === 'pause' || data.type === 'seek') {
          isSyncing = true; // Define a flag para evitar looping

          moviePlayer.currentTime = data.time;
          if (data.type === 'play') {
            moviePlayer.play();
            console.log('Sincronizar play no tempo:', data.time);
          } else if (data.type === 'pause') {
            moviePlayer.pause();
            console.log('Sincronizar pausa no tempo:', data.time);
          } else if (data.type === 'seek') {
            // O currentTime já foi definido, nenhuma ação adicional é necessária para seek
            console.log('Sincronizar busca no tempo:', data.time);
          }
          // Resetar a flag após um breve atraso para permitir que o navegador processe
          // ou imediatamente se a operação do player for síncrona
          setTimeout(() => { isSyncing = false; }, 100); 
        }
        // Lida com o compartilhamento de cenas
        else if (data.type === 'scene') {
          scenes = data.scenes;
          updateSceneList();
          console.log('Cenas recebidas:', data.scenes);
        }
        // Lida com a reação recebida
        else if (data.type === 'reaction') {
            console.log('Reação recebida:', data.emoji);
            displayReaction(data.emoji);
        }
      });
      conn.on('close', () => {
        connectionStatus.textContent = 'Status: Desconectado';
        connectionStatus.classList.add('status-error');
        console.log('Conexão PeerJS fechada');
        // Remove os ouvintes de evento quando a conexão é fechada
        moviePlayer.removeEventListener('play', handlePlayerPlay);
        moviePlayer.removeEventListener('pause', handlePlayerPause);
        moviePlayer.removeEventListener('seeked', handlePlayerSeeked);
        // Remove os ouvintes do overlay de play/pause
        moviePlayer.removeEventListener('play', updateOverlayPlayPauseButtonIcon);
        moviePlayer.removeEventListener('pause', updateOverlayPlayPauseButtonIcon);
        moviePlayer.removeEventListener('loadedmetadata', updateOverlayPlayPauseButtonIcon);
        // Remove os ouvintes do wrapper do vídeo
        videoPlayerWrapper.removeEventListener('mousemove', showControlsTemporarily);
        videoPlayerWrapper.removeEventListener('touchstart', showControlsTemporarily);
        clearTimeout(hideControlsTimeout); // Limpa qualquer timeout pendente
      });
    }

    // Funções de manipulador para eventos do player de vídeo
    function handlePlayerPlay() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando play sync:', moviePlayer.currentTime);
        conn.send({ type: 'play', time: moviePlayer.currentTime });
      }
    }

    function handlePlayerPause() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando pause sync:', moviePlayer.currentTime);
        conn.send({ type: 'pause', time: moviePlayer.currentTime });
      }
    }

    function handlePlayerSeeked() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando seek sync:', moviePlayer.currentTime);
        conn.send({ type: 'seek', time: moviePlayer.currentTime });
      }
    }

    // Função para carregar e compartilhar um arquivo de vídeo (para streaming)
    function uploadAndShareFile() {
      const file = fileInput.files[0];
      if (!file) {
        console.warn('Nenhum arquivo selecionado para upload.');
        alert('Por favor, selecione um arquivo de vídeo para carregar e iniciar o streaming.');
        return;
      }
      if (!conn || !conn.open) {
        console.warn('Não conectado a um peer para compartilhar o vídeo.');
        alert('Por favor, conecte-se a um amigo antes de tentar compartilhar o vídeo.');
        return;
      }

      // 1. Exibir o vídeo imediatamente no player do remetente
      const localUrl = URL.createObjectURL(file);
      currentFileUrl = localUrl;
      movieSource.src = localUrl;
      moviePlayer.load();
      moviePlayer.classList.add('fade-in');
      
      // Link de download local para o remetente (opcional, pode ser removido se o foco for só streaming)
      const downloadLink = document.createElement('a');
      downloadLink.href = localUrl;
      downloadLink.download = file.name;
      downloadLink.textContent = `Baixar ${file.name} (Local)`;
      downloadLink.className = 'text-pink-700 underline mt-2 block';
      downloadSection.innerHTML = '';
      downloadSection.appendChild(downloadLink);
      console.log('Vídeo carregado localmente e pronto para streaming:', file.name);

      // 2. Capturar o stream do player e enviá-lo via PeerJS call
      updateStreamingStatus('Preparando streaming...');

      moviePlayer.oncanplay = () => {
          let stream;
          try {
              stream = moviePlayer.captureStream(); // Captura o stream de áudio/vídeo do player
              console.log('Stream capturado do player:', stream);
              updateStreamingStatus('Stream capturado. Enviando...');
          } catch (error) {
              console.error('Erro ao capturar stream do player:', error);
              updateStreamingStatus('Erro ao capturar vídeo para streaming. Verifique as permissões.');
              alert('Não foi possível iniciar o streaming do vídeo. Por favor, verifique se o navegador permite a captura de mídia do vídeo (geralmente exige HTTPS ou localhost).');
              return;
          }

          if (stream && conn && conn.open) {
              const call = peer.call(conn.peer, stream); // Inicia uma chamada de vídeo para o peer
              call.on('stream', (remoteStream) => {
                  // Este 'stream' aqui seria um stream de volta do amigo,
                  // o que não é o nosso foco principal para essa funcionalidade.
                  // Pode ser ignorado por enquanto ou usado para algo mais avançado.
                  console.log('Recebido stream de volta (eco) do amigo, ou outro stream inesperado.');
              });
              call.on('close', () => {
                  console.log('Chamada de streaming encerrada.');
                  updateStreamingStatus('Streaming encerrado.');
              });
              updateStreamingStatus(`Streaming de '${file.name}' iniciado!`);
          } else {
              console.warn('Não foi possível iniciar a chamada de streaming: Sem stream ou conexão.');
              updateStreamingStatus('Erro: Não foi possível iniciar o streaming.');
          }
      };

      moviePlayer.onerror = () => {
          updateStreamingStatus('Erro ao carregar o vídeo localmente. Tente outro arquivo.');
          alert('Erro ao carregar o vídeo. Tente outro arquivo.');
          console.error('Erro ao carregar o vídeo localmente.');
      };
    }

    // Função para enviar o arquivo completo para download (opcional)
    function shareFileForDownload() {
      const file = fileInput.files[0];
      if (!file) {
        console.warn('Nenhum arquivo selecionado para download.');
        alert('Por favor, selecione um arquivo de vídeo para enviar para download.');
        return;
      }
      if (!conn || !conn.open) {
        console.warn('Não conectado a um peer para compartilhar o arquivo para download.');
        alert('Por favor, conecte-se a um amigo antes de tentar compartilhar o vídeo para download.');
        return;
      }

      // Se já houver um FileReader ativo de um envio anterior, aborta-o
      if (currentFileReader) {
          currentFileReader.abort();
          console.log('Envio de arquivo anterior abortado para iniciar um novo.');
          updateDownloadStatus(0, 0, '');
          document.getElementById('cancelDownloadButton').classList.add('hidden');
      }

      const chunkSize = 64 * 1024; // 64 KB por chunk
      let offset = 0;
      const fileTransferId = Date.now().toString(); // ID único para esta transferência

      const reader = new FileReader();
      currentFileReader = reader; // Armazena a referência para o FileReader atual
      currentFileTransferId = fileTransferId; // Armazena o ID da transferência

      document.getElementById('cancelDownloadButton').classList.remove('hidden'); // Mostra o botão Cancelar

      reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const totalChunks = Math.ceil(arrayBuffer.byteLength / chunkSize);

          // Envia metadados iniciais do arquivo para download
          conn.send({
              type: 'file-download-start', // Novo tipo para download
              fileTransferId: fileTransferId,
              fileName: file.name,
              fileSize: file.size,
              fileType: file.type,
              totalChunks: totalChunks
          });
          console.log(`Iniciando envio do arquivo para download: ${file.name} (${file.size} bytes) em ${totalChunks} chunks.`);
          updateDownloadStatus(0, file.size, file.name); // Atualiza progresso de download

          // Envia os chunks do arquivo
          while (offset < arrayBuffer.byteLength) {
              const chunk = arrayBuffer.slice(offset, offset + chunkSize);
              conn.send({
                  type: 'file-download-chunk', // Novo tipo para chunks de download
                  fileTransferId: fileTransferId,
                  chunkIndex: Math.floor(offset / chunkSize),
                  data: chunk // Envia o ArrayBuffer do chunk
              });
              offset += chunkSize;
              updateDownloadStatus(offset, file.size, file.name); // Atualiza progresso de download
          }
          console.log('Finalizado envio do arquivo para download:', file.name);
          updateDownloadStatus(file.size, file.size, file.name); // Garante 100%
      };
      
      reader.onloadend = function() { // Limpa as referências quando a leitura termina (sucesso ou aborto)
          currentFileReader = null;
          currentFileTransferId = null;
          document.getElementById('cancelDownloadButton').classList.add('hidden');
      };

      reader.readAsArrayBuffer(file); // Lê o arquivo como ArrayBuffer
    }

    // Função para cancelar o download em andamento (remetente)
    function cancelFileDownload() {
        if (currentFileReader) {
            currentFileReader.abort(); // Aborta a leitura do arquivo local
            console.log('Download de arquivo localmente cancelado (remetente).');
            updateDownloadStatus(0, 0, ''); // Limpa o status de progresso
            document.getElementById('cancelDownloadButton').classList.add('hidden'); // Esconde o botão

            if (conn && conn.open && currentFileTransferId) {
                // Envia uma mensagem de cancelamento para o peer remoto
                conn.send({ type: 'cancel-download', fileTransferId: currentFileTransferId });
                console.log('Mensagem de cancelamento enviada para o peer.');
            }
            currentFileReader = null; // Limpa a referência
            currentFileTransferId = null;
        } else {
            console.warn('Nenhum download ativo para cancelar.');
        }
    }


    // As funções syncPlay e syncPause agora são chamadas pelos eventos do player
    // e suas chamadas diretas via botão são mantidas por conveniência,
    // mas a sincronização principal é via eventos.
    function syncPlay() {
      if (conn && conn.open && currentFileUrl) {
        // Ação de play é tratada pelo evento 'play' do player
        moviePlayer.play();
      } else {
        console.warn('Não é possível sincronizar o play: não conectado ou nenhum vídeo carregado');
        alert('Por favor, conecte-se a um amigo e carregue um vídeo antes de sincronizar.');
      }
    }

    function syncPause() {
      if (conn && conn.open && currentFileUrl) {
        // Ação de pause é tratada pelo evento 'pause' do player
        moviePlayer.pause();
      } else {
        console.warn('Não é possível sincronizar a pausa: não conectado ou nenhum vídeo carregado');
        alert('Por favor, conecte-se a um amigo e carregue um vídeo antes de sincronizar.');
      }
    }

    // Função para adicionar uma cena (marcador de tempo)
    function addScene() {
      const time = moviePlayer.currentTime;
      const sceneName = prompt('Digite o nome da cena:') || `Cena ${scenes.length + 1}`;
      scenes.push({ name: sceneName, time: time });
      updateSceneList();
      if (conn && conn.open) {
        conn.send({ type: 'scene', scenes: scenes });
        console.log('Cena enviada:', sceneName, 'no tempo:', time);
      } else {
        console.warn('Não conectado a um peer para compartilhar a cena.');
        alert('Por favor, conecte-se a um amigo para compartilhar cenas.');
      }
    }

    // Função para atualizar a lista de cenas no menu
    function updateSceneList() {
      sceneList.innerHTML = '';
      scenes.forEach((scene, index) => {
        const li = document.createElement('li');
        li.className = 'scene-item p-2 rounded';
        li.textContent = `${scene.name} (${formatTime(scene.time)})`;
        li.onclick = () => {
          moviePlayer.currentTime = scene.time;
          if (conn && conn.open) {
            conn.send({ type: 'play', time: scene.time }); // Envia play para sincronizar jump de cena
          }
          moviePlayer.play();
          console.log('Pulou para a cena:', scene.name, 'no tempo:', scene.time);
        };
        sceneList.appendChild(li);
      });
    }

    // Função utilitária para formatar o tempo em minutos:segundos
    function formatTime(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = Math.floor(seconds % 60);
      return `${min}:${sec < 10 ? '0' : ''}${sec}`;
    }

    // Efeito de fade-in para elementos com a classe 'fade-in'
    document.querySelectorAll('.fade-in').forEach(el => {
      el.style.opacity = 0;
      setTimeout(() => {
        el.style.transition = 'opacity 1s ease';
        el.style.opacity = 1;
      }, 100);
    });
  </script>
</body>
</html>
