<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enchanted Pink Cinema Room</title>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js" onerror="handleScriptError('PeerJS')"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js" onerror="handleScriptError('Particles.js')"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Estilos Gerais para o Corpo */
    body {
      background: linear-gradient(135deg, #f9a8d4, #f472b6, #ec4899);
      font-family: 'Arial', sans-serif;
      overflow-x: hidden; /* CRÍTICO: Evita rolagem horizontal em qualquer cenário */
      animation: gradientShift 15s ease infinite;
      padding: 0; /* REMOVIDO padding padrão do body */
    }
    /* Animação de Fundo Gradiente */
    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* Contêiner Principal da Sala de Cinema */
    .cinema-container {
      background-color: rgba(255, 182, 193, 0.95);
      border-radius: 20px;
      padding: 20px; /* Padding padrão */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      transform: translateY(20px);
      animation: floatIn 1s ease-out forwards;
      /* Ajustes de responsividade aprimorados */
      width: 100%; /* Agora ocupa 100% da largura do body */
      max-width: 900px; /* Limite em telas maiores para não esticar demais */
      margin: 0 auto; /* Centraliza o container horizontalmente, sem margem vertical padrão */
      box-sizing: border-box; /* Garante que padding não cause overflow */
    }
    /* Animação de Entrada do Contêiner */
    @keyframes floatIn {
      to { transform: translateY(0); opacity: 1; }
    }
    /* Estilo do Player de Vídeo */
    video {
      border: 4px solid #ec4899;
      border-radius: 15px;
      transition: opacity 0.5s ease;
      width: 100%; /* Essencial: O vídeo sempre ocupa a largura total do seu contêiner */
      height: auto; /* Mantém a proporção do vídeo */
      display: block; /* Remove espaço extra abaixo do vídeo */
    }
    /* Estilo dos Botões */
    button {
      background: linear-gradient(45deg, #f472b6, #ec4899);
      color: white;
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      transition: transform 0.2s, box-shadow 0.2s;
      position: relative;
      overflow: hidden;
      width: 100%; /* Botões sempre ocupam 100% da largura em pequenos dispositivos */
      font-size: 1rem; /* Garante tamanho legível */
    }
    button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(236, 72, 153, 0.7);
    }
    button::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.4s, height 0.4s;
    }
    button:active::after {
      width: 200px;
      height: 200px;
    }
    /* Estilo da Área de Upload de Arquivos */
    .file-upload {
      background-color: #fef2f2;
      border: 3px dashed #f472b6;
      padding: 15px;
      border-radius: 15px;
      transition: transform 0.3s ease;
      box-sizing: border-box; /* Garante que padding não cause overflow */
    }
    .file-upload:hover {
      transform: scale(1.02);
    }
    /* Estilo do Menu Lateral */
    .menu {
      background: rgba(244, 114, 182, 0.9);
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease, opacity 0.3s ease; /* Adicionada transição para opacidade */
      z-index: 100; /* Garante que o menu fique sobre outros elementos */
      width: 80%; /* Ocupa mais largura em celulares para melhor usabilidade */
      max-width: 280px; /* Limita a largura máxima em telas maiores */
      box-sizing: border-box; /* Garante que padding não cause overflow */
      padding: 1rem; /* Espaçamento interno */
      pointer-events: auto; /* Permite interações quando visível */
    }
    .menu-hidden {
      transform: translateX(-150%); /* Aumentada a translação para garantir que suma completamente */
      opacity: 0; /* Torna o menu completamente invisível */
      pointer-events: none; /* Impede cliques em elementos invisíveis */
    }
    /* Estilo dos Itens da Lista de Cenas */
    .scene-item {
      cursor: pointer;
      transition: background-color 0.3s;
      padding: 0.75rem; /* Ajuste para melhor toque */
      border-radius: 8px; /* Cantos arredondados */
    }
    .scene-item:hover {
      background-color: #f9a8d4;
    }
    /* Partículas de Fundo */
    #particles-js {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    /* Estilos de Status de Conexão */
    .status-connected { color: #10b981; }
    .status-error { color: #ef4444; }

    /* NOVO: Estilos para Overlay de Reações */
    #reactionOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 90; /* Abaixo do menu, mas acima do conteúdo */
      pointer-events: none; /* Não bloqueia interação com a tela */
      overflow: hidden; /* Garante que emojis não saiam da tela se a animação os levar longe */
    }

    .reaction-emoji {
      position: absolute;
      font-size: 3rem; /* Tamanho inicial do emoji */
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.5); /* Centraliza e diminui */
      animation: fade-slide-up 2.5s ease-out forwards; /* Animação */
      text-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* Sombra para destaque */
    }

    /* Animação do Emoji */
    @keyframes fade-slide-up {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5) translateY(50px);
      }
      20% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.1) translateY(0);
      }
      80% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.9) translateY(-50px);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.7) translateY(-100px);
      }
    }

    /* NOVO: Estilos para o Wrapper do Player de Vídeo e Overlays Internos */
    .video-player-wrapper {
      position: relative;
      width: 100%;
      height: auto;
      max-width: 100%;
      overflow: hidden;
      border-radius: 15px; /* Arredondamento igual ao vídeo */
      box-shadow: 0 4px 15px rgba(0,0,0,0.2); /* Sombra suave */
    }

    .video-player-overlay {
      position: absolute;
      inset: 0; /* Cobre todo o wrapper do vídeo */
      z-index: 10; /* Acima do vídeo, abaixo dos controles nativos */
      pointer-events: none; /* Permite que cliques passem para o vídeo por padrão */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 1rem; /* Padding interno para os botões */
      background-color: rgba(0,0,0,0.05); /* Fundo sutilmente translúcido */
      transition: background-color 0.3s ease;
    }

    /* Efeito de hover no wrapper para escurecer o overlay */
    .video-player-wrapper:hover .video-player-overlay {
      background-color: rgba(0,0,0,0.15); /* Mais escuro no hover/touch */
    }

    /* Estilo do botão central de Play/Pause */
    #overlayPlayPauseButton {
      pointer-events: auto; /* Torna o botão clicável */
      background-color: rgba(236, 72, 153, 0.7); /* Rosa com transparência */
      color: white;
      border-radius: 9999px; /* Círculo completo */
      padding: 1rem;
      font-size: 3rem; /* Ícone grande */
      opacity: 0.8;
      transition: opacity 0.2s ease, background-color 0.2s ease;
      flex-shrink: 0; /* Evita encolhimento */
      display: flex;
      align-items: center;
      justify-content: center;
      width: 80px; /* Tamanho fixo */
      height: 80px; /* Tamanho fixo */
      margin: auto; /* Centraliza horizontal e verticalmente */
    }

    #overlayPlayPauseButton:hover {
      opacity: 1;
      background-color: rgba(236, 72, 153, 1);
    }

    /* Estilo dos botões de reação dentro do vídeo */
    .reaction-buttons-in-video button {
      pointer-events: auto; /* Torna os botões clicáveis */
      background-color: rgba(236, 72, 153, 0.7); /* Rosa com transparência */
      color: white;
      border-radius: 9999px; /* Círculo completo */
      padding: 0.5rem;
      font-size: 1.5rem; /* Tamanho do emoji */
      opacity: 0.8;
      transition: opacity 0.2s ease, background-color 0.2s ease;
      width: 50px; /* Tamanho fixo para facilitar o toque */
      height: 50px; /* Tamanho fixo */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reaction-buttons-in-video button:hover {
      opacity: 1;
      background-color: rgba(236, 72, 153, 1);
    }


    /* Media Queries para Ajustes Mais Finos em Telas de Celular */
    @media (max-width: 768px) { /* Para tablets e celulares */
      .cinema-container {
        padding: 15px; /* Reduz o padding geral para economizar espaço */
        border-radius: 15px; /* Ajusta o raio da borda */
      }
      h1 {
        font-size: 2rem; /* Títulos menores para caber melhor */
        margin-bottom: 1rem;
      }
      button {
        padding: 10px 15px; /* Botões um pouco menores */
        margin-bottom: 0.75rem; /* Espaçamento entre botões */
      }
      .flex-col-mobile { /* Usado para forçar empilhamento de botões, se necessário */
        flex-direction: column;
      }
      .input-full-width { /* Garante inputs que ocupam toda a largura */
        width: 100%;
        box-sizing: border-box;
      }
      .space-y-2 > *:not([hidden]) ~ *:not([hidden]) {
        margin-top: 0.5rem; /* Ajusta espaçamento vertical para elementos empilhados */
      }
      .reaction-emoji {
        font-size: 2.5rem; /* Menor em telas menores */
      }
      /* Ajustes para botões no vídeo em telas menores */
      #overlayPlayPauseButton {
        font-size: 2.5rem;
        width: 60px;
        height: 60px;
      }
      .reaction-buttons-in-video button {
        font-size: 1.25rem;
        width: 40px;
        height: 40px;
      }
    }

    @media (max-width: 480px) { /* Para celulares muito pequenos */
      .cinema-container {
        padding: 10px;
        border-radius: 10px; /* Cantos um pouco menos arredondados para economizar espaço */
      }
      h1 {
        font-size: 1.75rem; /* Títulos ainda menores */
      }
      button {
        font-size: 0.9rem;
        padding: 8px 12px;
        border-radius: 10px;
      }
      .menu {
        width: 90%; /* Menu ainda maior em telas muito pequenas */
      }
      .file-upload {
        padding: 10px;
      }
      .reaction-emoji {
        font-size: 2rem; /* Ainda menor em telas muito pequenas */
      }
      /* Ajustes para botões no vídeo em telas muito pequenas */
      #overlayPlayPauseButton {
        font-size: 2rem;
        width: 50px;
        height: 50px;
      }
      .reaction-buttons-in-video button {
        font-size: 1rem;
        width: 35px;
        height: 35px;
      }
    }
  </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen">
  <div id="particles-js"></div>
  <!-- NOVO: Overlay para as Reações Animadas -->
  <div id="reactionOverlay"></div>

  <!-- Arquivos de áudio de fallback (substitua por caminhos locais, se necessário) -->
  <audio id="clickSound" src="https://freesound.org/data/previews/171/171671_2437358-lq.mp3" onerror="handleAudioError('Click Sound')"></audio>
  <audio id="bgMusic" src="https://freesound.org/data/previews/235/235655_4229646-lq.mp3" loop onerror="handleAudioError('Background Music')"></audio>

  <div class="cinema-container w-full sm:max-w-xl md:max-w-3xl lg:max-w-5xl xl:max-w-6xl mx-auto relative flex flex-col items-center p-4">
    <h1 class="text-3xl sm:text-4xl font-bold text-pink-800 text-center mb-6 sm:mb-8 animate-pulse mt-4">
      Enchanted Pink Cinema Room
    </h1>
    
    <!-- Botão para Abrir o Menu -->
    <button onclick="toggleMenu()" class="absolute top-4 left-4 z-50 px-4 py-2 text-white rounded-lg text-sm sm:text-base">
      Menu
    </button>

    <!-- Menu Lateral -->
    <div id="menu" class="menu fixed top-0 left-0 h-full w-3/4 sm:w-64 p-4 menu-hidden shadow-lg">
      <h2 class="text-2xl text-pink-800 mb-4">Menu</h2>
      <button onclick="toggleMenu()" class="mb-4">Fechar Menu</button>
      <div class="space-y-3 mt-4">
        <button onclick="uploadAndShareFile()">Carregar & Transmitir Vídeo</button>
        <button onclick="syncPlay()">Sincronizar Play</button>
        <button onclick="syncPause()">Sincronizar Pausar</button>
        <button onclick="addScene()">Adicionar Cena</button>
      </div>
      <h3 class="text-xl text-pink-700 mt-6 mb-2">Cenas</h3>
      <ul id="sceneList" class="text-pink-800 space-y-2 max-h-48 overflow-y-auto"></ul>
    </div>
    
    <!-- Seção de Conexão PeerJS -->
    <div class="w-full mb-6 text-center fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Conectar com Amigo</h2>
      <p class="text-pink-800 mb-2">Seu Peer ID: <span id="myPeerId" class="font-bold"></span></p>
      <p id="connectionStatus" class="text-pink-800 mb-2">Status: Desconectado</p>
      <input id="remotePeerId" type="text" placeholder="Insira o Peer ID do amigo" 
             class="w-full p-2 mb-4 text-pink-800 border border-pink-700 rounded-lg focus:ring-2 focus:ring-pink-500 focus:border-transparent text-base">
      <div class="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-2">
        <button onclick="connectToPeer()" class="text-base">Conectar</button>
        <button onclick="retryConnection()" class="text-base">Tentar Novamente</button>
      </div>
    </div>
    
    <!-- Seção do Player de Filme/Vídeo - AGORA COM CONTROLES E REAÇÕES DENTRO -->
    <div class="w-full mb-6 fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Player de Filme</h2>
      <div class="video-player-wrapper">
        <video id="moviePlayer" controls class="w-full h-auto block bg-black">
          <source id="movieSource" src="" type="video/mp4">
          Seu navegador não suporta a tag de vídeo.
        </video>

        <!-- Overlay de Controles e Reações -->
        <div class="video-player-overlay">
          <!-- Controles Centrais de Play/Pause -->
          <div class="flex flex-grow items-center justify-center">
              <button id="overlayPlayPauseButton" onclick="toggleOverlayPlayPause()">
                  <span id="overlayPlayIcon">▶️</span>
                  <span id="overlayPauseIcon" class="hidden">⏸️</span>
              </button>
          </div>

          <!-- Botões de Reação (Canto Inferior Direito) -->
          <div class="flex justify-end gap-2 reaction-buttons-in-video">
              <button onclick="sendReaction('❤️')">❤️</button>
              <button onclick="sendReaction('😂')">😂</button>
              <button onclick="sendReaction('✋')">✋</button>
              <button onclick="sendReaction('😮')">😮</button>
              <button onclick="sendReaction('😢')">😢</button>
              <button onclick="sendReaction('✨')">✨</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Seção de Upload e Download de Arquivos -->
    <div class="file-upload w-full mb-6 fade-in px-4">
      <h2 class="text-xl text-pink-700 mb-2">Carregar um Filme/Vídeo</h2>
      <input type="file" id="fileInput" accept="video/*" class="mb-4 text-pink-800 w-full text-base">
      <button onclick="uploadAndShareFile()" class="text-base">Carregar & Transmitir Vídeo</button>
      
      <!-- BOTÃO E STATUS PARA DOWNLOAD OPCIONAL -->
      <div class="flex flex-col sm:flex-row justify-center space-y-2 sm:space-y-0 sm:space-x-2 mt-2">
        <button onclick="shareFileForDownload()" class="text-base">Enviar Arquivo para Download</button>
        <button id="cancelDownloadButton" onclick="cancelFileDownload()" class="text-base bg-red-500 hover:bg-red-600 hidden">Cancelar Download</button>
      </div>

      <div id="downloadSection" class="mt-4 text-center"></div>
      <p id="streamingStatus" class="w-full mt-4 text-center text-pink-800 font-semibold text-sm sm:text-base hidden"></p>
      <p id="downloadProgressStatus" class="w-full mt-4 text-center text-pink-800 font-semibold text-sm sm:text-base hidden"></p>
      
      <p class="text-xs text-pink-700 mt-2">
        A velocidade do download Peer-to-Peer depende da sua conexão e da do seu amigo. <br>
        Para compartilhar links públicos ou downloads mais rápidos de arquivos grandes, um servidor externo seria necessário.
      </p>
    </div>

    <!-- Seção de Reações Antiga Removida -->

  </div>

  <script>
    // Variáveis globais para PeerJS e elementos do DOM
    let peer;
    let conn;
    let currentFileUrl = null;
    let scenes = [];
    const moviePlayer = document.getElementById('moviePlayer');
    const movieSource = document.getElementById('movieSource');
    const fileInput = document.getElementById('fileInput');
    const downloadSection = document.getElementById('downloadSection');
    const myPeerIdDisplay = document.getElementById('myPeerId');
    const remotePeerIdInput = document.getElementById('remotePeerId');
    const connectionStatus = document.getElementById('connectionStatus');
    const sceneList = document.getElementById('sceneList');
    const clickSound = document.getElementById('clickSound');
    const bgMusic = document.getElementById('bgMusic');
    const reactionOverlay = document.getElementById('reactionOverlay'); // Elemento da sobreposição de reação
    // Variáveis para controle de download
    let receivedFiles = new Map(); // Mapa para armazenar dados de arquivos recebidos (para reconstrução)
    let currentFileReader = null; // Referência ao FileReader atual para permitir abortar
    let currentFileTransferId = null; // ID da transferência de arquivo atual

    // Nova flag para controlar sincronização para evitar loops infinitos
    let isSyncing = false;

    // NOVO: Elementos do overlay de play/pause
    const overlayPlayPauseButton = document.getElementById('overlayPlayPauseButton');
    const overlayPlayIcon = document.getElementById('overlayPlayIcon');
    const overlayPauseIcon = document.getElementById('overlayPauseIcon');


    // Função para lidar com erros de carregamento de scripts externos
    function handleScriptError(scriptName) {
      connectionStatus.textContent = `Status: Erro ao carregar ${scriptName}. Por favor, atualize a página.`;
      connectionStatus.classList.add('status-error');
      console.error(`${scriptName} falhou ao carregar`);
    }

    // Função para lidar com erros de carregamento de áudio
    function handleAudioError(audioName) {
      console.warn(`${audioName} falhou ao carregar. Considere hospedar arquivos de áudio localmente.`);
    }

    // Inicialização do Particle.js para efeitos visuais
    if (typeof particlesJS !== 'undefined') {
      particlesJS('particles-js', {
        particles: {
          number: { value: 80, density: { enable: true, value_area: 800 } },
          color: { value: '#f9a8d4' },
          shape: { type: 'circle' },
          opacity: { value: 0.5, random: true },
          size: { value: 3, random: true },
          line_linked: { enable: false },
          move: { enable: true, speed: 2, direction: 'none', random: true }
        },
        interactivity: { detect_on: 'canvas', events: { onhover: { enable: true, mode: 'repulse' } } }
      });
    } else {
      console.warn('Particle.js não carregado');
    }

    // Configuração e reprodução da música de fundo
    bgMusic.volume = 0.2;
    bgMusic.play().catch(() => console.log('Música de fundo bloqueada pelo navegador'));

    // Adiciona som de clique a todos os botões
    document.querySelectorAll('button').forEach(button => {
      button.addEventListener('click', () => {
        clickSound.currentTime = 0;
        clickSound.play().catch(() => console.log('Som de clique bloqueado'));
      });
    });

    // Função para alternar a visibilidade do menu lateral
    function toggleMenu() {
      const menu = document.getElementById('menu');
      menu.classList.toggle('menu-hidden');
    }

    // Inicialização do PeerJS com servidores STUN/TURN para melhor conectividade
    peer = new Peer({
      host: '0.peerjs.com',
      secure: true,
      port: 443,
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay.project', credential: 'openrelayproject' }
        ]
      }
    });

    // Evento quando o PeerJS é aberto e recebe um ID
    peer.on('open', (id) => {
      myPeerIdDisplay.textContent = id;
      connectionStatus.textContent = 'Status: Aguardando conexão...';
      connectionStatus.classList.remove('status-error', 'status-connected');
      console.log('PeerJS inicializado com ID:', id);
    });

    // Evento para lidar com novas conexões recebidas
    peer.on('connection', (connection) => {
      conn = connection;
      setupConnection();
    });

    // Evento para lidar com erros do PeerJS
    peer.on('error', (err) => {
      connectionStatus.textContent = `Status: Erro - ${err.type}. ${err.type === 'peer-unavailable' ? 'Verifique o Peer ID ou garanta que o amigo esteja online.' : 'Verifique a rede ou tente novamente.'}`;
      connectionStatus.classList.add('status-error');
      console.error('Erro PeerJS:', err);
    });

    // Função para iniciar a conexão com outro Peer
    function connectToPeer() {
      const remoteId = remotePeerIdInput.value.trim();
      if (remoteId) {
        connectionStatus.textContent = 'Status: Conectando...';
        connectionStatus.classList.remove('status-error', 'status-connected');
        conn = peer.connect(remoteId);
        setupConnection();
      } else {
        connectionStatus.textContent = 'Status: Insira um Peer ID válido';
        connectionStatus.classList.add('status-error');
        console.warn('Nenhum Peer ID inserido');
      }
    }

    // Função para tentar novamente a conexão PeerJS
    function retryConnection() {
      if (remotePeerIdInput.value.trim()) {
        connectionStatus.textContent = 'Status: Tentando novamente a conexão...';
        connectionStatus.classList.remove('status-error', 'status-connected');
        peer.destroy(); // Destrói a instância PeerJS atual
        // Cria uma nova instância PeerJS
        peer = new Peer({
          host: '0.peerjs.com',
          secure: true,
          port: 443,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay.project', credential: 'openrelayproject' }
            ]
          }
        });
        peer.on('open', (id) => {
          myPeerIdDisplay.textContent = id;
          connectionStatus.textContent = 'Status: Aguardando conexão...';
          connectToPeer(); // Tenta conectar automaticamente após reabrir
        });
        peer.on('error', (err) => {
          connectionStatus.textContent = `Status: Erro - ${err.type}. ${err.type === 'peer-unavailable' ? 'Verifique o Peer ID ou garanta que o amigo esteja online.' : 'Verifique a rede ou tente novamente.'}`;
          connectionStatus.classList.add('status-error');
          console.error('Erro de nova tentativa PeerJS:', err);
        });
        peer.on('connection', (connection) => {
          conn = connection;
          setupConnection();
        });
      } else {
        connectionStatus.textContent = 'Status: Insira um Peer ID válido para tentar novamente';
        connectionStatus.classList.add('status-error');
      }
    }

    // Função para atualizar o status do streaming (não é progresso de download de arquivo)
    function updateStreamingStatus(text, hideAfterDelay = true) {
      const statusDiv = document.getElementById('streamingStatus');
      statusDiv.textContent = text;
      statusDiv.classList.remove('hidden');
      if (hideAfterDelay) {
        setTimeout(() => { statusDiv.classList.add('hidden'); }, 5000);
      }
    }

    // Função para atualizar o progresso do download do arquivo
    function updateDownloadStatus(received, total, fileName = '') {
      const statusDiv = document.getElementById('downloadProgressStatus');
      statusDiv.classList.remove('hidden');
      if (total === 0) {
        statusDiv.textContent = '';
        statusDiv.classList.add('hidden');
        return;
      }
      const percentage = Math.min(100, Math.floor((received / total) * 100));
      let statusText = `Baixando '${fileName}': ${percentage}%`;

      if (percentage === 100) {
        statusDiv.textContent = `${statusText} - Completo!`;
        setTimeout(() => { statusDiv.classList.add('hidden'); }, 3000);
      } else {
        statusDiv.textContent = statusText;
      }
    }

    // Função para exibir uma reação animada
    function displayReaction(emoji) {
        const reactionDiv = document.createElement('div');
        reactionDiv.className = 'reaction-emoji';
        reactionDiv.textContent = emoji;

        // Posição aleatória na tela (aproximadamente, para não ficar sempre no mesmo lugar)
        const x = Math.random() * (window.innerWidth - 100) + 50; // Largura - 100px para bordas + 50px offset
        const y = Math.random() * (window.innerHeight - 100) + 50; // Altura - 100px para bordas + 50px offset
        
        reactionDiv.style.left = `${x}px`;
        reactionDiv.style.top = `${y}px`;

        reactionOverlay.appendChild(reactionDiv);

        // Remove o emoji após a animação (2.5 segundos)
        setTimeout(() => {
            reactionDiv.remove();
        }, 2500);
    }

    // Função para enviar a reação via PeerJS
    function sendReaction(emoji) {
        if (conn && conn.open) {
            conn.send({ type: 'reaction', emoji: emoji });
            console.log('Reação enviada:', emoji);
            displayReaction(emoji); // Exibe a reação localmente também
        } else {
            console.warn('Não conectado a um peer para enviar a reação.');
            displayReaction(emoji); // Apenas exibe localmente se não conectado
        }
    }

    // NOVO: Função para atualizar o ícone do botão de play/pause no overlay
    function updateOverlayPlayPauseButtonIcon() {
        if (moviePlayer.paused) {
            overlayPlayIcon.classList.remove('hidden');
            overlayPauseIcon.classList.add('hidden');
            overlayPlayPauseButton.classList.remove('hidden'); // Mostra o botão quando pausado
        } else {
            overlayPlayIcon.classList.add('hidden');
            overlayPauseIcon.classList.remove('hidden');
            overlayPlayPauseButton.classList.remove('hidden'); // Mantém visível mas pode ser escondido por CSS no futuro
        }
    }

    // NOVO: Função para alternar play/pause no overlay
    function toggleOverlayPlayPause() {
        if (moviePlayer.paused) {
            moviePlayer.play();
        } else {
            moviePlayer.pause();
        }
    }


    // Configura os ouvintes de evento para a conexão PeerJS
    function setupConnection() {
      conn.on('open', () => {
        connectionStatus.textContent = 'Status: Conectado!';
        connectionStatus.classList.add('status-connected');
        console.log('Conexão PeerJS estabelecida');

        // Adiciona ouvintes de evento ao player de vídeo após a conexão ser aberta
        moviePlayer.addEventListener('play', handlePlayerPlay);
        moviePlayer.addEventListener('pause', handlePlayerPause);
        moviePlayer.addEventListener('seeked', handlePlayerSeeked);
        
        // NOVO: Adiciona ouvintes para o botão de overlay play/pause
        moviePlayer.addEventListener('play', updateOverlayPlayPauseButtonIcon);
        moviePlayer.addEventListener('pause', updateOverlayPlayPauseButtonIcon);
        moviePlayer.addEventListener('loadedmetadata', updateOverlayPlayPauseButtonIcon); // Para estado inicial
        updateOverlayPlayPauseButtonIcon(); // Chama para definir o estado inicial
      });

      // Lida com o recebimento de stream de mídia (áudio/vídeo)
      peer.on('call', (call) => {
          console.log('Recebendo chamada de vídeo do peer...');
          updateStreamingStatus('Recebendo streaming...');
          
          call.answer(); // Responde à chamada de vídeo
          call.on('stream', (remoteStream) => {
              console.log('Stream de vídeo recebido do peer!');
              moviePlayer.srcObject = remoteStream; // Define o stream recebido como fonte do player
              moviePlayer.play().catch(e => console.error("Erro ao tentar tocar stream recebido:", e)); // Tenta dar play automaticamente
              updateStreamingStatus('Streaming recebido e reproduzindo!');
          });
          call.on('close', () => {
              console.log('Stream de vídeo encerrado.');
              updateStreamingStatus('Streaming encerrado.');
          });
      });

      conn.on('data', (data) => {
        // Lida com o início da transferência de arquivo para download
        if (data.type === 'file-download-start') {
          receivedFiles.set(data.fileTransferId, {
            fileName: data.fileName,
            fileType: data.fileType,
            totalChunks: data.totalChunks,
            receivedChunks: new Array(data.totalChunks), // Array para armazenar os chunks na ordem correta
            receivedSize: 0,
            fileSize: data.fileSize
          });
          console.log(`Recebendo arquivo para download: ${data.fileName} (${data.fileSize} bytes)`);
          updateDownloadStatus(0, data.fileSize, data.fileName);
        } 
        // Lida com os chunks de dados do arquivo para download
        else if (data.type === 'file-download-chunk') {
          const fileData = receivedFiles.get(data.fileTransferId);
          if (fileData) {
            fileData.receivedChunks[data.chunkIndex] = data.data; // Armazena o chunk na posição correta
            fileData.receivedSize += data.data.byteLength;
            updateDownloadStatus(fileData.receivedSize, fileData.fileSize, fileData.fileName);

            // Verifica se todos os chunks foram recebidos
            if (fileData.receivedSize === fileData.fileSize) {
                // Monta o arquivo completo a partir dos chunks
                const fullBlob = new Blob(fileData.receivedChunks, { type: fileData.fileType });
                const url = URL.createObjectURL(fullBlob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = fileData.fileName;
                downloadLink.textContent = `Baixar ${fileData.fileName}`;
                downloadLink.className = 'text-pink-700 underline mt-2 block';
                
                // Limpar links de download anteriores e adicionar o novo
                downloadSection.innerHTML = ''; 
                const downloadPrompt = document.createElement('p');
                downloadPrompt.className = 'text-pink-800 text-sm mt-2';
                downloadPrompt.textContent = 'Arquivo recebido para download:';
                downloadSection.appendChild(downloadPrompt);
                downloadSection.appendChild(downloadLink);

                console.log('Arquivo recebido e pronto para download:', fileData.fileName);

                receivedFiles.delete(data.fileTransferId); // Limpa o estado da transferência
                updateDownloadStatus(fileData.fileSize, fileData.fileSize, fileData.fileName); // Garante 100%
            }
          }
        }
        // Lida com a mensagem de cancelamento de download
        else if (data.type === 'cancel-download') {
            const fileData = receivedFiles.get(data.fileTransferId);
            if (fileData) {
                receivedFiles.delete(data.fileTransferId);
                updateDownloadStatus(0, 0, ''); // Limpa o status
                console.log(`Download de arquivo '${fileData.fileName}' cancelado pelo remetente.`);
                document.getElementById('downloadProgressStatus').textContent = `Download de '${fileData.fileName}' cancelado.`;
                setTimeout(() => { document.getElementById('downloadProgressStatus').classList.add('hidden'); }, 3000);
            }
        }
        // Lida com mensagens de sincronização (play, pause, seek)
        else if (data.type === 'play' || data.type === 'pause' || data.type === 'seek') {
          isSyncing = true; // Define a flag para evitar looping

          moviePlayer.currentTime = data.time;
          if (data.type === 'play') {
            moviePlayer.play();
            console.log('Sincronizar play no tempo:', data.time);
          } else if (data.type === 'pause') {
            moviePlayer.pause();
            console.log('Sincronizar pausa no tempo:', data.time);
          } else if (data.type === 'seek') {
            // O currentTime já foi definido, nenhuma ação adicional é necessária para seek
            console.log('Sincronizar busca no tempo:', data.time);
          }
          // Resetar a flag após um breve atraso para permitir que o navegador processe
          // ou imediatamente se a operação do player for síncrona
          setTimeout(() => { isSyncing = false; }, 100); 
        }
        // Lida com o compartilhamento de cenas
        else if (data.type === 'scene') {
          scenes = data.scenes;
          updateSceneList();
          console.log('Cenas recebidas:', data.scenes);
        }
        // Lida com a reação recebida
        else if (data.type === 'reaction') {
            console.log('Reação recebida:', data.emoji);
            displayReaction(data.emoji);
        }
      });
      conn.on('close', () => {
        connectionStatus.textContent = 'Status: Desconectado';
        connectionStatus.classList.add('status-error');
        console.log('Conexão PeerJS fechada');
        // Remove os ouvintes de evento quando a conexão é fechada
        moviePlayer.removeEventListener('play', handlePlayerPlay);
        moviePlayer.removeEventListener('pause', handlePlayerPause);
        moviePlayer.removeEventListener('seeked', handlePlayerSeeked);
        // NOVO: Remove os ouvintes do overlay de play/pause
        moviePlayer.removeEventListener('play', updateOverlayPlayPauseButtonIcon);
        moviePlayer.removeEventListener('pause', updateOverlayPlayPauseButtonIcon);
        moviePlayer.removeEventListener('loadedmetadata', updateOverlayPlayPauseButtonIcon);
      });
    }

    // Funções de manipulador para eventos do player de vídeo
    function handlePlayerPlay() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando play sync:', moviePlayer.currentTime);
        conn.send({ type: 'play', time: moviePlayer.currentTime });
      }
    }

    function handlePlayerPause() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando pause sync:', moviePlayer.currentTime);
        conn.send({ type: 'pause', time: moviePlayer.currentTime });
      }
    }

    function handlePlayerSeeked() {
      if (!isSyncing && conn && conn.open && currentFileUrl) {
        console.log('Enviando seek sync:', moviePlayer.currentTime);
        conn.send({ type: 'seek', time: moviePlayer.currentTime });
      }
    }

    // Função para carregar e compartilhar um arquivo de vídeo (para streaming)
    function uploadAndShareFile() {
      const file = fileInput.files[0];
      if (!file) {
        console.warn('Nenhum arquivo selecionado para upload.');
        alert('Por favor, selecione um arquivo de vídeo para carregar e iniciar o streaming.');
        return;
      }
      if (!conn || !conn.open) {
        console.warn('Não conectado a um peer para compartilhar o vídeo.');
        alert('Por favor, conecte-se a um amigo antes de tentar compartilhar o vídeo.');
        return;
      }

      // 1. Exibir o vídeo imediatamente no player do remetente
      const localUrl = URL.createObjectURL(file);
      currentFileUrl = localUrl;
      movieSource.src = localUrl;
      moviePlayer.load();
      moviePlayer.classList.add('fade-in');
      
      // Link de download local para o remetente (opcional, pode ser removido se o foco for só streaming)
      const downloadLink = document.createElement('a');
      downloadLink.href = localUrl;
      downloadLink.download = file.name;
      downloadLink.textContent = `Baixar ${file.name} (Local)`;
      downloadLink.className = 'text-pink-700 underline mt-2 block';
      downloadSection.innerHTML = '';
      downloadSection.appendChild(downloadLink);
      console.log('Vídeo carregado localmente e pronto para streaming:', file.name);

      // 2. Capturar o stream do player e enviá-lo via PeerJS call
      updateStreamingStatus('Preparando streaming...');

      moviePlayer.oncanplay = () => {
          let stream;
          try {
              stream = moviePlayer.captureStream(); // Captura o stream de áudio/vídeo do player
              console.log('Stream capturado do player:', stream);
              updateStreamingStatus('Stream capturado. Enviando...');
          } catch (error) {
              console.error('Erro ao capturar stream do player:', error);
              updateStreamingStatus('Erro ao capturar vídeo para streaming. Verifique as permissões.');
              alert('Não foi possível iniciar o streaming do vídeo. Por favor, verifique se o navegador permite a captura de mídia do vídeo (geralmente exige HTTPS ou localhost).');
              return;
          }

          if (stream && conn && conn.open) {
              const call = peer.call(conn.peer, stream); // Inicia uma chamada de vídeo para o peer
              call.on('stream', (remoteStream) => {
                  // Este 'stream' aqui seria um stream de volta do amigo,
                  // o que não é o nosso foco principal para essa funcionalidade.
                  // Pode ser ignorado por enquanto ou usado para algo mais avançado.
                  console.log('Recebido stream de volta (eco) do amigo, ou outro stream inesperado.');
              });
              call.on('close', () => {
                  console.log('Chamada de streaming encerrada.');
                  updateStreamingStatus('Streaming encerrado.');
              });
              updateStreamingStatus(`Streaming de '${file.name}' iniciado!`);
          } else {
              console.warn('Não foi possível iniciar a chamada de streaming: Sem stream ou conexão.');
              updateStreamingStatus('Erro: Não foi possível iniciar o streaming.');
          }
      };

      moviePlayer.onerror = () => {
          updateStreamingStatus('Erro ao carregar o vídeo localmente. Tente outro arquivo.');
          alert('Erro ao carregar o vídeo. Tente outro arquivo.');
          console.error('Erro ao carregar o vídeo localmente.');
      };
    }

    // Função para enviar o arquivo completo para download (opcional)
    function shareFileForDownload() {
      const file = fileInput.files[0];
      if (!file) {
        console.warn('Nenhum arquivo selecionado para download.');
        alert('Por favor, selecione um arquivo de vídeo para enviar para download.');
        return;
      }
      if (!conn || !conn.open) {
        console.warn('Não conectado a um peer para compartilhar o arquivo para download.');
        alert('Por favor, conecte-se a um amigo antes de tentar compartilhar o vídeo para download.');
        return;
      }

      // Se já houver um FileReader ativo de um envio anterior, aborta-o
      if (currentFileReader) {
          currentFileReader.abort();
          console.log('Envio de arquivo anterior abortado para iniciar um novo.');
          updateDownloadStatus(0, 0, '');
          document.getElementById('cancelDownloadButton').classList.add('hidden');
      }

      const chunkSize = 64 * 1024; // 64 KB por chunk
      let offset = 0;
      const fileTransferId = Date.now().toString(); // ID único para esta transferência

      const reader = new FileReader();
      currentFileReader = reader; // Armazena a referência para o FileReader atual
      currentFileTransferId = fileTransferId; // Armazena o ID da transferência

      document.getElementById('cancelDownloadButton').classList.remove('hidden'); // Mostra o botão Cancelar

      reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const totalChunks = Math.ceil(arrayBuffer.byteLength / chunkSize);

          // Envia metadados iniciais do arquivo para download
          conn.send({
              type: 'file-download-start', // Novo tipo para download
              fileTransferId: fileTransferId,
              fileName: file.name,
              fileSize: file.size,
              fileType: file.type,
              totalChunks: totalChunks
          });
          console.log(`Iniciando envio do arquivo para download: ${file.name} (${file.size} bytes) em ${totalChunks} chunks.`);
          updateDownloadStatus(0, file.size, file.name); // Atualiza progresso de download

          // Envia os chunks do arquivo
          while (offset < arrayBuffer.byteLength) {
              const chunk = arrayBuffer.slice(offset, offset + chunkSize);
              conn.send({
                  type: 'file-download-chunk', // Novo tipo para chunks de download
                  fileTransferId: fileTransferId,
                  chunkIndex: Math.floor(offset / chunkSize),
                  data: chunk // Envia o ArrayBuffer do chunk
              });
              offset += chunkSize;
              updateDownloadStatus(offset, file.size, file.name); // Atualiza progresso de download
          }
          console.log('Finalizado envio do arquivo para download:', file.name);
          updateDownloadStatus(file.size, file.size, file.name); // Garante 100%
      };
      
      reader.onloadend = function() { // Limpa as referências quando a leitura termina (sucesso ou aborto)
          currentFileReader = null;
          currentFileTransferId = null;
          document.getElementById('cancelDownloadButton').classList.add('hidden');
      };

      reader.readAsArrayBuffer(file); // Lê o arquivo como ArrayBuffer
    }

    // Função para cancelar o download em andamento (remetente)
    function cancelFileDownload() {
        if (currentFileReader) {
            currentFileReader.abort(); // Aborta a leitura do arquivo local
            console.log('Download de arquivo localmente cancelado (remetente).');
            updateDownloadStatus(0, 0, ''); // Limpa o status de progresso
            document.getElementById('cancelDownloadButton').classList.add('hidden'); // Esconde o botão

            if (conn && conn.open && currentFileTransferId) {
                // Envia uma mensagem de cancelamento para o peer remoto
                conn.send({ type: 'cancel-download', fileTransferId: currentFileTransferId });
                console.log('Mensagem de cancelamento enviada para o peer.');
            }
            currentFileReader = null; // Limpa a referência
            currentFileTransferId = null;
        } else {
            console.warn('Nenhum download ativo para cancelar.');
        }
    }


    // As funções syncPlay e syncPause agora são chamadas pelos eventos do player
    // e suas chamadas diretas via botão são mantidas por conveniência,
    // mas a sincronização principal é via eventos.
    function syncPlay() {
      if (conn && conn.open && currentFileUrl) {
        // Ação de play é tratada pelo evento 'play' do player
        moviePlayer.play();
      } else {
        console.warn('Não é possível sincronizar o play: não conectado ou nenhum vídeo carregado');
        alert('Por favor, conecte-se a um amigo e carregue um vídeo antes de sincronizar.');
      }
    }

    function syncPause() {
      if (conn && conn.open && currentFileUrl) {
        // Ação de pause é tratada pelo evento 'pause' do player
        moviePlayer.pause();
      } else {
        console.warn('Não é possível sincronizar a pausa: não conectado ou nenhum vídeo carregado');
        alert('Por favor, conecte-se a um amigo e carregue um vídeo antes de sincronizar.');
      }
    }

    // Função para adicionar uma cena (marcador de tempo)
    function addScene() {
      const time = moviePlayer.currentTime;
      const sceneName = prompt('Digite o nome da cena:') || `Cena ${scenes.length + 1}`;
      scenes.push({ name: sceneName, time: time });
      updateSceneList();
      if (conn && conn.open) {
        conn.send({ type: 'scene', scenes: scenes });
        console.log('Cena enviada:', sceneName, 'no tempo:', time);
      } else {
        console.warn('Não conectado a um peer para compartilhar a cena.');
        alert('Por favor, conecte-se a um amigo para compartilhar cenas.');
      }
    }

    // Função para atualizar a lista de cenas no menu
    function updateSceneList() {
      sceneList.innerHTML = '';
      scenes.forEach((scene, index) => {
        const li = document.createElement('li');
        li.className = 'scene-item p-2 rounded';
        li.textContent = `${scene.name} (${formatTime(scene.time)})`;
        li.onclick = () => {
          moviePlayer.currentTime = scene.time;
          if (conn && conn.open) {
            conn.send({ type: 'play', time: scene.time }); // Envia play para sincronizar jump de cena
          }
          moviePlayer.play();
          console.log('Pulou para a cena:', scene.name, 'no tempo:', scene.time);
        };
        sceneList.appendChild(li);
      });
    }

    // Função utilitária para formatar o tempo em minutos:segundos
    function formatTime(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = Math.floor(seconds % 60);
      return `${min}:${sec < 10 ? '0' : ''}${sec}`;
    }

    // Efeito de fade-in para elementos com a classe 'fade-in'
    document.querySelectorAll('.fade-in').forEach(el => {
      el.style.opacity = 0;
      setTimeout(() => {
        el.style.transition = 'opacity 1s ease';
        el.style.opacity = 1;
      }, 100);
    });
  </script>
</body>
</html>
